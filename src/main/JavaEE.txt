jsp - java server page

1. Zaleznosc do Mavena dla JavaEE

<dependencies>
<dependency>
<groupId>javax</groupId>
<artifactId>javaee-api</artifactId>
<version>8.1</version>
</dependency>
<dependencies>

2. Przykladowy Servlet:

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet("/FindUserByServlet")
public class FindUserByServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

    }
}

3. Przykladowy response Servlet w html

 PrintWriter printWriter = resp.getWriter();
            printWriter.println("<!DOCTYPE html>");
            printWriter.println("<html>");
            printWriter.println("<body>");
            printWriter.println("ID: " + foundUser.getId() + ", \nname: " + foundUser.getName() + ", Login: "
                    + foundUser.getLogin() + ", age: " + foundUser.getAge() + ", pulse: " + pulse);
            printWriter.println("</body>");
            printWriter.println("</html>");
            
            
lub:

"<!DOCTYPE html><html><body>"+user+"</body></html>")

## DEFINICJE

1.  EJB opiera się na tworzeniu komponentów (ziaren EJB), które mogą być
osadzane na serwerze aplikacji (tzw. kontenerze EJB), który z kolei udostępnia
je do wykonania lokalnie (dostęp z części aplikacji uruchomionej na tej samej
wirtualnej maszynie) lub zdalnie poprzez protokół RMI. Główną zaletą EJB jest nakierowanie projektanta na pewne sprawdzone
sposoby rozwiązania typowych problemów w systemie rozproszonym:
-zarządzanie połączeniami,
-transakcja rozproszona,
-mapowanie danych na model obiektowy itp.

Message-Driven - Komponent sterowany wiadomościami, często opierający się na mechanizmie JMS (część specyfikacji JEE). Komponent ten, nie jest wywoływany bezpośrednio przez klienta. Reaguje na wiadomości umieszczone, np. w kolejce. Taka obsługa pozwala na podejście całkowicie asynchroniczne. Nie posiada żadnych informacji o systemie, który przetwarza te informacje wie tylko gdzie się znajduje. W EJB który działa poprzez RMI czyli zdalne wywoływanie metod, podaje się interfejsy, które są niezbędne do wywoływania metod biznesowych.

Session Bean: Stanowość

- Stateful (stanowy) – pamięta stan dla konkretnej sesji z klientem, „stan konwersacji” z klientem, obejmujący wiele wywołań metod.

- Stateless (bezstanowy) – nie pamięta konwersacji z klientem, nie zachowuje swojego stanu nawet na czas trwania jednej sesji, jego stan jest zachowany na czas wywołania jednej metody, serwer nie daje gwarancji utrzymania tego stanu na dalszym etapie komunikacji

- Singleton – istnieje tylko jeden stan (jedna instancja) w skali całej aplikacji, bez względu na to ilu klientów zostanie do niego podłączonych

Inversion of Control - jest jednym ze wzorców projektowych, przekazanie zarządzania zależnościami naszemu kontenerowi aplikacji JEE.

loose coupling -ma na celu jak najmniejsze powiązanie obiektów między sobą

DI - Dependency injection, Kontener posiadający funkcjonalność wstrzykiwania nazywany jest kontenerem DI

CDI - Context and Dependency Inj., Zestaw usług pozwalający na zachowanie loose coupling (jak najmniejsze powiązanie obiektów między sobą) między warstwami aplikacji. Pozwala na wstrzyknięcie większości obiektów występujących w ramach aplikacji. Nie muszą być one EJB.

EJB > CDI
Przewagą EJB nad CDI będzie fakt, że kontener przejmie kontrolę nad transakcjami, bezpieczeństwem, współbieżnością, pulami obiektów.

@EJB vs @Inject
@EJB pozwala na wstrzykiwanie tylko i wyłącznie obiektów zarządzanych przez kontener EJB.
@Inject obsługiwana jest przez kontener CDI i pozwala na wstrzykiwanie zarówno obiektów zarządzanych przez kontener EJB jak i pozostałych beanów.

-Filtry - wykorzystywane w servletach oraz JSP są klasami używanymi do filtrowania i podejmowania akcji w komunikacji klient serwer. Przykładowe/sugerowane przeznaczenie filtrów: Autentykacja, Autoryzacja, Szyfrowanie, Kompresja danych, Weryfikacja i modyfikacja danych zanim trafią do servletu.

Filtr jest klasą implementującą interfejs javax.servlet.Filter
Posiada trzy metody:
@Override
public void init(FilterConfig filterConfig) throws ServletException {
}
@Override
public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain
filterChain)
throws IOException, ServletException {
}
@Override
public void destroy() {
}
  
## ADNOTACJE

@Remove - Po wywołaniu takiej metody jest to sygnał dla kontenera, aby usunąć bezstanowe ziarno ze swoich zasobów, a w samej metodzie możemy dokonać "sprzątania" takiego jak np. zamknięcie połączeń z bazą danych, czy zwrócenie ich do puli.

W przypadku, gdy nasze ziarno korzysta z dodatkowych zasobów jak np. połączenie z bazą danych, to warto dodać także dwie metody powiązane z cyklem życia:
@PrePassivate - Zwolnienie zasobu przechowywanego przez obiekt ziarna
@PostActivate - Pozwala pobrac zasob z bazy danych ponownie przy kolejnej aktywacji.

@Local oznacza, że metody będzie można wywoływać maksymalnie z innego modułu jednak mieszczące się w tej samej paczce WAR
@Remote oznacza, że metody będzie można wywoływać nie tylko tak jak w @Local ale również z całkowicie niezależnego modułu mieszczącego się zarówno na tym samym serwerze jak również na zdalnej maszynie
@EJB/@Inject - Użycie zdefiniowanych EJB wykorzystuje te adnotacje. Dependency Injection jako wzorzec architektury oprogramowania. Charakteryzuje się architekturą pluginów zamiast jawnego tworzenia
bezpośrednich zależności między klasami. Polega na przekazywaniu między obiektami gotowych, ustanowionych obiektów danych klas (beanów).

Oznaczenia beanów CDI:

@ApplicationScoped – stan współdzielony przez użytkowników w kontekście całej aplikacji (zeby cos zmienic trzeba zresetowac aplikacje)

@SessionScoped – stan na czas interakcji użytkownika z aplikacją webową w ramach wielu requestów, przy dodaniu takie adnotacji trzeba dodac po nazwie klasy implements Serializable. (zeby cos zmienic trzeba zakonczyc sesje, np. wylogowac sie, zalezy ile trwa sesja)

@RequestScoped – stan na czas interakcji użytkownika z aplikacją webową w ramach jednego requestu (zeby cos zmienic trzeba odswiezyc przegladarke)


## EJB - pom.xml - dodajemy w plugins, ktore jest w build pod finalName

<plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-ejb-plugin</artifactId>
                <version>3.0.0</version>
                <configuration>
                    <ejbVersion>3.2</ejbVersion>
                    <generateClient>true</generateClient>
                    <clientIncludes>
                        <clientInclude>com/isa/jakarta/repository/UserRepositoryRemote.class
                        </clientInclude>
                    </clientIncludes>
                </configuration>
 </plugin>





















